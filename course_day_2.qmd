---
title: "Introduction to Python\nDay 2"
author: "Verjinia Metodieva and Daniel Parthier"
date: 2025-02-04
format:
    revealjs:
        incremental: true 
        highlight-style: oblivion
        theme: night
        drop:
            engine: pyodide
        mermaid: 
          theme: dark
        margin: 0.01
        embed-resources: true
    pdf:
        mermaid: 
          theme: neutral
        highlight-style: github
execute:
    eval: true
    echo: true
ipynb-shell-interactivity: all
revealjs-plugins:
  - drop
---

# Jupyter Notebook


# Recap homework

Let's take a look at the homework

# Functions part 2

# Goal of today

<small>

```{.python}
# TODO: add useful example to introduce class
# Some function we have to decide
def useful_function(par1, par2, par3):
    # some loop
    for i in par1:
        if par1 == "something":
            # do something
        else:
            pass # or something else
    return None # or an object 
```
</small>

::: {.notes}
_ _ _ _ _ _ _
This is an example to showcase what we will achieve today.
:::


## Global vs. Local

<!--some high contrast colour choices : #DEC62F, #DE2F99, #2FD2DE,  #696969 (DimGrey), #6a9956 (comment green), #ce9178 (doc string red)-->

::: {.fragment}
- Scopes 
- Local variables live and die inside a function
- Global variables
    - declared outside of fucntions
    - lost when programme closed

:::

::: {.notes}
_ _ _ _ _ _ _
- global scope - of the whole program
- local scope of a separate function
- Local variables
    - Variables that live only inside of functions, minutes in our example
    - They no longer exist once the function is done executing  show it by running minutes
    - If we try to access their values outside the function, we will encounter an error
- Global variables
    - variables defined outside any function
:::

# Short interlude

::: {style="font-size: 80%;"}

::: {.fragment .nonincremental}
- Whole numbers: Integers `int`

``` {python}
#| code-line-numbers: false
type(1)
```
:::

::: {.fragment .nonincremental}
- Real numbers: Floats `float`

``` {python}
#| code-line-numbers: false
type(1.0)
```
:::

::: {.fragment .nonincremental}
- Most of the time it might not matter^[In python]

``` {python}
#| code-line-numbers: false
1 == 1.0
```
:::

- Sometimes there is a difference and we will see later why

:::

::: {.notes}
_ _ _ _ _ _ _
Most of the time python handles the integer vs. float automatically. You will not have to worry about assigning. 
:::

# Conditional statements

The important question of what to do "if" something happens.

- Programming languages are languages
- `if` something is `True`
    - you should do `something`
- `else`
    - do `something else`

::: {.fragment}
```{.python}
if statement:
    print("the statement is true")
else:
    print("the statement is false")
```
:::

::: {.notes}
_ _ _ _ _ _ _
This structure is the simplest of conditionals. The statement has to be `True` to enter the `if` part to execute. Should the statement by `False` it will skip and enter the `else` part which will then be executed.
:::

## Multiple if-statements

```{python}
#| code-annotations: true
#| eval: false
value = 3
if value == 1: # <1>
    print("the value is 2")
elif value == 2: # <2>
    print("the value is 2")
elif value == 3: # <3>
    print("the value is 3") # <4>
else:
    print("the value is something else")
```

1. Check if `value` is `1`
2. Check if `value` is `2`
3. Check if `value` is `3`
4. Execute block

::: {.fragment}
```{python}
#| echo: false
value = 3
if value == 1:
    print("the value is 2")
elif value == 2:
    print("the value is 2")
elif value == 3:
    print("the value is 3")
else:
    print("the value is something else")
```
:::

::: {.notes}
_ _ _ _ _ _ _
Statements will be checked sequentially. Should one statement be `True` the corresponding part of the `if`/`elif` block will be executed. All other blocks after that will be skipped. This means one `True` expression is enough. 
:::

## How to check if everything is true?


## For loops

``` {.python}
for *element* in *iterable*:
    *body*
 ```

- iteration is the repetition of a process until a specific condition is met
- what's iterable?


::: {.fragment}
 ``` {.python}
 # calcualte a sum
list_to_sum = [2,3,4,5,7]
num_sum = 0
for val in list_to_sum:
    num_sum = num_sum + val
 ```
:::

::: {.notes}
_ _ _ _ _ _ _
- For loop = An iterating function used to execute statements repeatedly.
- Iterate = In programming, iteration is the repetition of a code or a process until a specific condition is met.
- Iterables	= objects in Python that you can iterate over, e.g. container types (list, numpy  arrays,  tuples, sets), dictionary.keys(), strings
:::


## <u> TO DO </u>

Given: <br> 
A = [3, 4, 5, 9, 12, 87, -65, 300, 450, -32]

Use *for loops* to: <br>
1. Add 3 to each element of the list <br>
2. Calculate the average of the list, but negative values are calcualted as 0s <br>
3. Find the maximum valuen <br>
4. Find the index (position) of the max value <br>


## Index based *for loops* - range()

::: {.fragment}
- generates integer sequences
- range(n) generates the series of n values from 0 to n − 1
:::

::: {.fragment}
``` {python}
for i in range(5):
    print(i)
```

``` {python}

# looping through data indices. find the max
B = [1, 4, 6, 7, 89, 54]
big_indx = 0
for i in range(len(B)):
    if B[i] > B[big_indx]:
        big_indx = i
print('The max value in B is', B[big_indx], 'found on position', big_indx)
```

:::

## Index based *for loops* - enumerate()

- assigns a count to each item within an iterable and returns it as an enumerate object

::: {.fragment}

``` {python}
import numpy as np

array_a = np.arange(20, 25)
for indx, val in enumerate(array_a):
    print('the index is', indx)
    print('the value is', val)
```

:::

::: {.fragment}
! range() and enumerate() - none of the two returs a list of objects!
:::

::: {.notes}
_ _ _ _ _ _ _
- motivation: limitation in 'simple' for loops - we don't know the position of an element within a sequence, as we experienced in the last example
- range(n) generates the series of n values from 0 to n − 1
- precisely the series of valid indices into a sequence of length n
- range() - returns a range object that is iterable
- enumerate() - returns an enumerate object that is also iterable
- they are mainly used in loops
:::


## Index based *for loops* [1]

### enumerate()

- one way to avoid nested loops

## Break and continue statements

- break - oimmediately terminates the loop

::: {.notes}
_ _ _ _ _ _ _
- a break statement that immediately terminate a while or for loop when executed within its body
- 
:::


## List comprehension

## Compare different functions

# While loops

- Perform a task `while` something is `True`
- Be careful:
    - Some loops never finish (get stuck)
    - Make sure that condition for ending the loop can be fullfilled

``` {.python}
while check_condition:
    perform_task()

```

## Errors and how to read them

There are useful resources regarding errors

- Simply googling works surprisingly well
- You will often end up on [stackoverflow](https://stackoverflow.com/)
    - There is no question which was not already asked^[if that is not true open up a question]

::: {.fragment}
![](/img/stackoverflow.png){width="500px" .absolute right=0}
:::

***

### Types of errors

1. SyntaxErrors
2. NameError
3. TypeError
4. IndexError
5. AttributeError
6. etc.

***

### Fix errors